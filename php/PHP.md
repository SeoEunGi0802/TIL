# PHP
------------
<details>
<summary>2021-04-21</summary>
<div markdown="2021-04-21">

## 2021-04-21(졸작으로 인해 늦어진 TIL 작성)
------------
PHP는 C언어를 기반으로 만들어진 서버 측에서 실행되는 '서버 사이드 스크립트' 언어이다.<br/>
서버 사이드 스크립트란 서버 측에서 수행하는 처리를 의미한다.<br/>
브라우저에서 요청한 HTML 문서에 서버 사이드 스크립트 언어의 코드가 포함되어 있으면, 서버는 이 부분을 자신이 처리하고 그 결과를 브라우저에 보내 주고
이러한 서버 사이드에서 자주 사용하는 스크립트 언어가 바로 PHP입니다.<br/>
PHP로 작성된 코드를 HTML 코드 안에 추가하면, 웹 서버는 해당 코드를 해석하여 자동으로 HTML 문서를 생성하여서 PHP를 사용하면 동적으로 빠르게 HTML 문서를 만들 수 있다.<br/>
+ 서버에 미리 저장된 파일이 아닌 서버에 있는 데이터들을 서버 사이드 스크립트 언어로 가공하여 생성되는 페이지를 동적 웹 페이지(dynamic web page)라고 한다.<br/>
+ [인용 TCP-SCHOOL](http://www.tcpschool.com/php/intro)

------------
## 변수 선언
PHP에서 변수를 선언할 때는 변수의 이름 앞에 달러($) 기호를 사용하여 선언하고 따로 타입을 명시하지 않는다.<br/><br/>

+ 정수
```php
$a = 10;
$b = 20;
$c = $a + $b; //$c == 30;
```

+ 실수
```php
$a2 = 0.1;
$b2 = 0.2;
$c2 = $a2 + $b2; //$c2 == 0.3;
```

+ 문자열
```php
$str = "PHP";
$str2 = "HI";
(잘못된 방법)$str3 = $str + $str2; //$str == 0; PHP에서는 문자열에 '+'기호를 넣어줄 경우 숫자로 인식되어 값이 0으로 나온다.
$str3 = $str.$str2 //$str3 == "PHPHI";
```

+ 배열
```php
$arr = [1, 2, 3, 4, 5];
$arr2 = [1, '2', "3", '4', 5];
$arr3 = $arr.$arr2 //당연히 오류 발생. C언어를 기반으로 하였으므로 반복문으로 출력이 가능하다.
```
<br/>
+ 알아둬서 나쁘지 않은 것<br/>
실수의 값을 연결하여 보여주고 싶을때 아래와 같이<br/>
$str4 = $a.$b로 선언할 경우 -> $str4 == 0.10.2 이렇게 나온다. 이는<br/>
$str3 = "$a"."$b"로 해결이 가능하다.<br/>
배열을 합치고 싶으면 array_merge라는 함수를 이용하여 가능하다. -> $arr3 = array_merge($arr, $arr2) -> $arr3 == [1, 2, 3, 4, 5, 1, '2', "3", '4', 5];<br/><br/><br/>

## 변수 이름의 생성 규칙
변수의 이름은 그 변수가 가지는 데이터의 의미를 잘 나타내도록 작성하는 것이 좋다.<br/>
PHP에서는 이러한 변수의 이름을 작성할 때 반드시 지켜야 하는 다음과 같은 규칙이 있다.

1. 변수의 이름은 영문 대소문자, 숫자, 언더스코어(_)로만 구성된다.
2. 변수의 이름은 숫자와의 구분을 빠르게 하기 위해 숫자로는 시작할 수 없다.
3. 변수의 이름에는 공백이 포함될 수 없다.
4. 변수의 이름으로 PHP에서 미리 정의한 $this는 사용할 수 없다.
5. 변수의 이름은 대소문자를 구분한다.<br/><br/><br/>

## 변수의 종류
PHP에서 변수는 스크립트 내 어느 곳에서나 선언할 수 있다.<br/>
변수의 유효 범위(variable scope)란 특정 변수를 참조되거나 사용할 수 있는 스크립트 내의 범위를 의미한다.<br/>
PHP에서는 이러한 변수의 유효 범위에 따라 변수의 종류를 다음과 같이 구분한다.<br/>

1. 지역 변수(local variable)
    + 지역 변수<br/>
         함수 내부에서 선언된 변수는 오직 함수 내부에서만 접근할 수 있다.<br/>
         또한, 함수 내부에서 선언된 변수는 함수의 호출이 종료되면 메모리에서 제거된다.<br/>
         이렇게 함수 내부에서 선언된 변수를 지역 변수(local variable)라고 한다.<br/><br/>
         
2. 전역 변수(global variable)
    + 전역 변수<br/>
    함수 밖에서 선언된 변수는 함수 밖에서만 바로 접근할 수 있다.<br/>
    함수 밖에서 선언된 변수를 함수 내부에서 접근하고자 할 때는 global 키워드를 함께 사용해야 한다.<br/>
    이렇게 함수 밖에서 선언된 변수를 전역 변수(global variable)라고 한다.<br/><br/>
    
    + 슈퍼 글로벌, 슈퍼전역변수, 초전역변수<br/>
    PHP는 미리 정의된 전역 변수인 슈퍼 글로벌(superglobal)을 제공한다.<br/>
    이러한 슈퍼 글로벌은 특별한 선언 없이 스크립트 내의 어디에서라도 바로 사용할 수 있다.<br/>
    PHP에서 제공하는 슈퍼 글로벌은 다음과 같다.<br/><br/>

    #### $GLOBALS
    변수 앞에 global을 붙여 사용한다.
    ```php
        $x = 1;
        function globalfun() {
            global $x;
        }
    ```
    이렇게 하면 함수globalfun() 내부에서 $x의 값을 사용할 수 있지만 다른 함수에서는 불가능 하므로 다시 선언 해주어야 한다.<br/><br/>

    #### $_SERVER
    사용시 서버에 대한 정보를 찾아올 수 있다.<br/>
    그뿐만 아니라 $_SERVER 변수를 통해 사용자가 PC에서 접속했는지 서버에서 접속했는지 알 수 있다.<br/>
    $_SERVER['PHP_SELF'] 현재 실행중인 파일 이름<br/>
    $_SERVER[´SERVER_NAME´] 호스트 서버 이름 등등<br/><br/>

    #### $_GET
    HTML form이 method="GET"으로 제출되었을 때 form 데이터를 수집하는 데 사용하고 또한 변수를 전달할 때도 사용한다.
    ```php
    <form action="<?php echo $_SERVER['PHP_SELF'];?>" method="GET">
        ID : <input type="text" name="GET_TEST">
        <input type="submit">
    </form>
    ```
    ```php
    $id = $_GET['GET_TEST'];
    echo $id;
    ```
    이런 식으로 가능하다.<br/>
    GET 방식 이므로 입력한 값이 '123' 이라면 URL에 "http://localhost/~~~?GET_TEST=123"으로 나타난다.<br/>
    여기서 'echo'는 글자를 HTML 으로 변환하여 출력해준다. 비슷한 코드로 print가 있다.<br/><br/>

    #### $_POST
    HTML form이 method="POST"으로 제출되었을 때 form 데이터를 수집하는 데 사용하고 또한 변수를 전달할 때도 사용한다.
    ```php
    <form action="<?php echo $_SERVER['PHP_SELF'];?>" method="POST">
        ID : <input type="text" name="POST_TEST">
        <input type="submit">
    </form>
    ```
    ```php
    $id = $_POST['POST_TEST'];
    echo $id;
    ```
    위 GET방식과 매우 비슷하지만 둘의 차이는 크게 URL에 나타나지 않는다.<br/><br/>

    #### $_REQUEST
    HTML form이 method="POST" 또는 method="GET"으로 제출되었을 때 form 데이터를 수집하는 데 사용하고 또한 변수를 전달할 때도 사용한다.<br/>
    ```php
    <form action="<?php echo $_SERVER['PHP_SELF'];?>" method="POST or GET">
        ID : <input type="text" name="REQUEST_TEST">
        <input type="submit">
    </form>
    ```
    ```php
    $name = $_REQUEST['fname'];
    echo $name;
    ```
    GET, POST 둘다 상관 없이 HTML form이 제출한 데이터를 받아올 수 있다.<br/><br/>

    #### $_FILES
    HTML form안 input type="file"일때 업로드된 파일 데이터를 수집하는 데 사용한다.<br/>
    ```php
    <form enctype="multipart/form-data" action="<?php echo $_SERVER['PHP_SELF']; ?>" method="POST">
        FILE : <input type="file" name="FILE_TEST">
        <input type="submit">
    </form>
    ```
    ```php
    if (count($_FILES)) {
        echo "<pre>";
        echo "업로드된 파일의 대한 정보\n";
        print_r($_FILES);
        echo "</pre>";
    }
    ```
    위 코드는 결과물이 예상이 잘 안될것이다. 만약 파일을 선택한 후 전송 버튼을 누르게 되면
    ```php
    Array
    (
    [FILE_TEST] => Array
        (
            [name] => 파일이름
            [type] => 파일의 타입
            [tmp_name] => 파일의 위치경로
            [error] => 에러 검출 횟수
            [size] => 파일의 크기(byte)
        )
    )
    ```
    업로드된 파일의 대한 정보가 나타나게 된다.<br/><br/>

    #### $_COOKIE
    $_COOKIE는 쿠키에 대한 코드 입니다.<br/>
    먼저 쿠키란?<br/>
    쿠키(cookie)란 웹 사이트에 접속할 때 서버에 의해 사용자의 컴퓨터에 저장되는 정보를 의미한다.<br/>
    쿠키는 사용자를 식별하는데 종종 사용된다.<br/>
    쿠키는 서버가 사용자 컴퓨터에 내장하는 작은 파일이다.<br/>
    같은 컴퓨터가 브라우져로 페이지를 요청할 때마다, 쿠키도 함께 보낸다.<br/>
    웹 사이트는 이렇게 저장된 사용자의 정보를 클라이언트(client) 측의 컴퓨터에 남겨서 필요할 때마다 재사용한다.<br/>
    현재 이러한 쿠키는 로그인 정보나 장바구니 정보를 저장하는 용도로 많이 활용되고 있다.<br/>
    하지만 사용자의 정보가 컴퓨터에 고스란히 남기 때문에 사생활 침해의 우려가 있으며, 보안과 관련된 이슈를 가지고 있다.<br/>

    //setcookie (이름, 값, 폐기 일자);<br/>
    //더 자세한 속성 : setcookie ( $name [, $value [, $expire [, $path [, $domain [, $secure [, $httponly ]]]]]] )
    ```php
    if ($_POST != null) {
        $POST_COOKIE = $_POST['COOKIE_TEST'];
        setcookie("COOKIE", $POST_COOKIE, time() + 60 * 1);
        header("Location: ./test.php");
        }
    ```
    setcookie() 함수의 매개변수 중에서 쿠키 명을 제외한 매개변수는 모두 옵션이다.<br/>
    쿠키는 명시된 지속 시간이 지나면 무효가 되며, 지속 시간을 전달하지 않으면 브라우저가 닫히기 전까지 계속 유효하다.<br/>
    또한, 사용자가 직접 삭제하지 않는 한 브라우저에 계속 남아 있을 것이다.<br/>
    쿠키를 생성할 때 유효한 주소와 경로를 매개변수로 전달할 수 있다.<br/>
    만약 HTTPS 프로토콜에서 사용하려면 secure 값을 true로 설정해야 한다.
    또한, HTTP 프로토콜에서만 사용하도록 하려면 httponly 값을 true로 설정하면 된다.
    ```php
    <?php
        $cookie = $_COOKIE['COOKIE'];
        echo "쿠키 정보：{$cookie}";
    ?>
    
    <form method="POST" action="./test.php">
        <input type="text" name="COOKIE_TEST">
        <input type="submit" value="전송">
    </form>
    ```
    PHP에서 unset() 함수나 setcookie() 함수를 사용하면, 생성된 쿠키를 삭제할 수 있다.<br/>
    ```php
    unset($_COOKIE["COOKIE"]);
    or
    setcookie($cookieName, $POST_COOKIE, time()-60, "/");
    ```
    <br/>

    #### $_SESSION
    $_SESSION는 쿠키에 대한 코드 입니다.<br/>
    세션(session)이란 웹 사이트의 여러 페이지에 걸쳐 사용되는 사용자 정보를 저장하는 방법을 의미한다.<br/>
    사용자가 브라우저를 닫아 서버와의 연결을 끝내는 시점까지를 세션이라고 한다.<br/>
    쿠키는 클라이언트 측의 컴퓨터에 모든 데이터를 저장한다. 하지만 세션은 서비스가 돌아가는 서버 측에 데이터를 저장하고, 세션의 키값만을 클라이언트 측에 남겨둔다.<br/>
    브라우저는 필요할 때마다 이 키값을 이용하여 서버에 저장된 데이터를 사용하게 된다.<br/>
    이러한 세션은 보안에 취약한 쿠키를 보완해주는 역할을 하고 있다.<br/><br/>

    PHP에서는 session_start() 함수를 이용하여 새로운 세션을 시작하거나, 기존의 세션을 다시 시작할 수 있다.<br/>
    session_start() 함수는 세션 아이디가 이미 존재하는지를 확인하고, 존재하지 않으면 새로운 아이디를 만든다.<br/>
    만약 이미 존재하는 세션 아이디가 있을 때는 원래 있던 세션 변수를 다시 불러와서 사용할 수 있도록 한다.<br/>
    세션 아이디는 웹 서버에 의해 무작위로 만들어진 숫자이다.<br/>
    이 세션 아이디는 세션이 유지되는 동안 클라이언트 측에 저장되며, 세션 변수를 등록하는 키로 사용된다.<br/>
    웹 서버에서는 클라이언트로부터 받아온 세션 아이디를 가지고, 해당 아이디에 대응되는 세션 변수에 접근할 수 있다.<br/>
    쿠키와 마찬가지로 세션도 어떤 헤더보다도 먼저 생성해야만 한다.<br/>
    세션의 지속 시간은 쿠키와 달리 php.ini 파일에 설정되어 있으므로, 따로 명시해주지 않아도 된다.
    ```php
    session_start();
    ```
    세션이 생성되고 나면 세션 변수를 수퍼 글로벌인 $_SESSION 배열에 등록할 수 있다.<br/>
    이때 세션 변수의 이름이 키값이 되며, 이 내용은 서버 측에 저장된다.<br/>
    등록된 세션 변수는 등록을 해지하지 않는 한 세션이 끝날 때까지 유지된다.
    ```php
    $_SESSION["name"] = "김씨";
    $_SESSION["age"] = 21;
    ```

    생성된 세션 변수는 $_SESSION["~"]으로 접근할 수 있다.
    ```php
    session_start();
    session = "session_test";
    $_SESSION['SESSION'] = $session;
    ```
    ```php
    echo "세션 정보：{$_SESSION['SESSION']}";
    ```
    세션 변수의 사용이 모두 끝나면, 세션 변수의 등록을 해지할 수 있다.<br/>
    unset() 함수를 사용하면, 특정 이름의 세션 변수만을 해지할 수 있다.<br/>
    현재 등록된 모든 세션 변수를 해지하고자 할 때에는 session_unset() 함수를 사용하면 된다.<br/>
    또한, 세션을 자체를 완전히 종료하려면 session_destroy() 함수를 사용하여 세션 아이디를 삭제하면 된다.<br/>
    ```php
    unset($_SESSION["session"]); //해당 세션 등록 해지
    session_unset(); //모든 세션 등록 해지
    session_destroy(); //세션 자체를 종료
    ```
    <br/>

3. 정적 변수(static variable)
    + 정적 변수<br/>
    정적 변수(static variable)란 함수 내부에서 static 키워드로 선언한 변수를 의미한다.<br/>
    함수 내부에서 선언된 정적 변수는 함수의 호출이 종료되더라도 메모리상에서 사라지지 않다.<br/>
    하지만 지역 변수처럼 해당 함수 내부에서만 접근할 수 있다.<br/>
    ```php
    function staticfun() {
        static $cnt = 0;
        echo "static count의 값 : {$cnt}<br>";
        $cnt++;
    }
    staticfun();
    staticfun();
    staticfun();
    ```
------------
</div>
</details>
<br>

<details>
<summary>2021-04-22</summary>
<div markdown="2021-04-22">

## 2021-04-22
#### 중간고사

</div>
</details>
<br>

<details>
<summary>2021-04-24</summary>
<div markdown="2021-04-24">

## 2021-04-24
------------
## 상수
상수란 변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간을 의미한다.<br/>
하지만 상수가 변수와 다른 점은 한 번 선언되면, 스크립트가 실행되는 동안 그 데이터를 변경하거나 해제할 수 없다는 점이다.<br/>
PHP에서는 define() 함수를 사용하여 상수를 선언할 수 있다.<br/>
 + define()
    ```php
    define(상수이름, 상수 값, 대소문자구분여부)
    //대소문자구분여부의 디폴트(false, 빈칸 가능)는 구분하고, true가 들어가면 구분을 하지 않는다.
    ```
    ```php
    function definefunc(){
        echo def; // 에러발생
        define("def", "define() 테스트");
        echo def; // 정상출력
        }
        
        definefunc();
        echo "<br>".def; // 정상출력(이해를 돕기위한 <br>태그 삽입)
    ```
    <br/>

## 마법 상수
PHP는 어떤 스크립트에서도 사용할 수 있는 미리 정의된 다양한 상수를 제공한다.<br/>
// pre 태그는 '```' 로 감싸면 제대로 보여지지 않아서 평문으로 작성 //<br/>

    <?php
    echo "<pre>";
    print_r(get_defined_constants(true));
    echo "</pre>";
    ?>

위 코드를 실행 시키면 [이러한](/php/php_magicconstants.md) 화면이 나온다.<br/>
PHP는 위와 같이 미리 정의된 상수 이외에도 어디에 사용하느냐에 따라 용도가 변경되는 8개의 마법 상수를 제공한다.<br/>
이러한 마법 상수는 대소문자를 구분하지 않는다.<br/>

    __LINE__ : 파일의 현재 줄 번호를 반환한다.

    __FILE__ : 파일의 전체 경로와 이름을 반환한다. include 내부에서 사용할 경우 include된 파일명을 반한다.

    __DIR__	: 파일의 디렉터리를 반환한다. 포함한 파일 안에서 사용할 경우 포함된 파일의 디렉터리를 반환한다.
              dirname(__FILE__)과 같은 결과를 반한다.

    __FUNCTION__ : 함수의 이름을 반환한다.
    
    __CLASS__ : 클래스의 이름을 반환한다. 클래스 이름은 대소문자를 구분한다.

    __TRAIT__ : 클래스의 이름을 반환한다. 클래스 이름은 대소문자를 구분한다. 트레이트의 이름은 트레이트를 선언한 네임스페이스를 포함한다.

    __METHOD__	클래스의 메소드 이름을 반환한다.

    __NAMESPACE__	현재 네임스페이스의 이름을 반환한다.


    <?php
    echo " __LINE__ : " . __LINE__;
    echo "<br>";
    echo " __FILE__ : " . __FILE__;
    echo "<br>";
    echo " __DIR__ : " . __DIR__;
    echo "<br>";
    echo "dirname(__FILE__) : " . dirname(__FILE__);
    echo "<br>";
    echo " __FUNCTION__ : " . __FUNCTION__;
    echo "<br>";
    echo " __CLASS__ : " . __CLASS__;
    echo "<br>";
    echo "__TRAIT__ : " . __TRAIT__;
    echo "<br>";
    echo " __METHOD__ : " . __METHOD__;
    ?>
    
 
## 기본 타입
타입(data type)이란 프로그램에서 다룰 수 있는 값의 종류를 의미한다.<br/>
PHP에서는 여러 가지 형태의 타입을 미리 정의하여 제공하고 있으며, 이것을 기본 타입이라고 한다.<br/>
PHP가 제공하는 기본 타입은 다음과 같다.<br/>

1. 불리언(boolean)
    + 불리언은 참(true)과 거짓(false)을 표현
    + PHP에서 불리언은 상수인 true와 false를 사용해 나타내며, 대소문자를 구분하지는 않는다. 아래 값들은 모두 false 값을 가진다.
         - 불리언 : false
         - 정수 : 0
         - 실수 : 0.0
         - 빈 문자열과 문자열 "0"
         - 빈 배열
         - NULL

    ```php
    var_dump((bool) false);
    echo "<br>";
    var_dump((bool) "false");
    echo "<br>";
    var_dump((bool) 0);
    echo "<br>";
    var_dump((bool) -100);
    echo "<br>";
    var_dump((bool) 0.0);
    echo "<br>";
    var_dump((bool) "");
    echo "<br>";
    var_dump((bool) "0");
    echo "<br>";
    var_dump((bool) array());
    echo "<br>";
    var_dump((bool) null);
    ```
    <br/>

2. 정수(integer)
    + 정수(integer)는 부호를 가지는 소수부가 없는 수를 의미한다.
    + PHP에서 정수의 표현 범위는 운영체제에 따라 달라지며, 64비트 운영체제를 기준으로 -263 ~ (263 - 1) 사이의 값을 가진다.
    + PHP에서는 부호가 없는 정수(unsigned integer)는 지원하지 않는다.
    + 정수는 10진수, 8진수(0으로 시작), 16진수(0x로 시작)로도 표현할 수 있다.

    ```php
    echo "INT 타입의 크기는 " . PHP_INT_SIZE . "바이트 입니다.<br>";
    echo "INT 타입이 표현할 수 있는 가장 큰 수는 " . PHP_INT_MAX . " 입니다.<br>";
    $int1 = 9223372036854775807; // PHP_INT_MAX의 값
    $int2 = 9223372036854775808; // PHP_INT_MAX보다 1큰 값
    echo $int1 . "<br>" . $int2;
    ```
    위의 예제에서 상수 PHP_INT_SIZE는 정수 타입의 크기를<br/>
    PHP_INT_MAX의 값은 정수 타입이 표현할 수 있는 가장 큰 수를 나타낸다.<br/>
    PHP에서는 변수에 정수의 최대 범위를 넘는 값이 대입되면, 그 변수는 자동으로 실수형(float)으로 인식된다.<br/><br/>

3. 실수(float)
    + 실수는 소수부나 지수부를 가지는 수를 의미하며, 정수보다 더 넓은 표현 범위를 가진다.
    + PHP에서 실수의 표현 범위는 운영체제에 따라 달라지지만 대략 ~1.8e307까지 표현할 수 있다.
    + 컴퓨터에서 실수를 표현하는 방식은 반드시 오차가 존재하는 한계를 지니므로, 실수형끼리 직접 값을 비교하는 것은 피하는 것이 좋다.

    ```php
    echo "FLOAT 타입이 표현할 수 있는 가장 큰 수는 " . PHP_FLOAT_MAX . " 입니다.<br>";
    $int1 = 1.7976931348623E+308; // PHP_INT_MAX의 값
    $int2 = 1.7976931348623E+308; // PHP_INT_MAX보다 1큰 값
    $int2 = $int2 + pow(10, 295); // pow(a, b) -> a의 b제곱값

    echo $int1 . "<br>" . $int2;
    echo "<br>".pow(10, 295);
    ```
    PHP에서는 e 지수 표현과 E 지수 표현이 모두 가능하다.<br/>
    변수에 실수의 최대 범위를 넘는 값이 대입되면, 그 변수는 자동으로 미리 정의된 상수인 INF로 인식된다.<br/>
    ```php
    $int1 = 13910230.324923490324923490324923490324923490324923490; // PHP_INT_MAX의 값
    $int2 = 13910230.324923490324923490324923490324923490324923490111233123;

    if($int1 == $int2){
        echo "같아요";
    } else {
        echo "틀려요";
    }
    ```
    $int1과 $int2는 다르지만 코드를 실행시키면 "같아요"가 출력된다.<br/><br/>

4. 문자열(string)
    + 문자열(string)은 일련의 연속된 문자(character)들의 집합을 의미한다.
    + PHP에서 문자열 리터럴은 큰따옴표("")나 작은따옴표('')로 감싸서 표현한다.
    + 아스키(ASCII) 인코딩 환경에서 영문자는 한 글자당 1바이트, 한글은 한 글자당 2바이트로 표현된다.
    + UTF-8 인코딩 환경에서는 영문자는 한 글자당 1바이트, 한글은 한 문자당 3바이트로 표현된다.

    ```php
    $str1 = "PHP";
    $str2 = "가";

    echo strlen($str1); // 3
    echo "<br>";
    echo strlen($str2); // 18
    ```
    한글이 한 문자당 3바이트로 처리되는 것을 확인할 수 있다.<br/><br/>

5. 배열(array)
    + PHP에서 배열(array)은 한 쌍의 키(key)와 값(value)으로 이루어진 맵(map)으로 구성되는 순서가 있는 집합을 의미한다.
    + map의 키값으로는 정수와 문자열만이 가능하며, 하나의 배열에 두 가지 키값을 같이 사용할 수 있다.
    + 정수와 문자열 이외에 다른 타입의 값을 키값으로 사용하면, 내부적으로 다음과 같이 타입 변환이 이루어진다.
        - 불리언은 true는 1로, false는 0으로 자동 타입 변환된다.
        - 유효한 숫자로만 이루어진 문자열은 정수나 실수로 자동 타입 변환된다.
        - 실수는 소수 부분이 제거되고, 정수로 자동 타입 변환된다.
        - NULL은 빈 문자열("")로 자동 타입 변환된다.
        - 배열과 객체는 배열의 키값으로 사용할 수 없다.
        ```php
        $arr = array(
            1 => "첫 번째 값",   // PHP의 배열에서 키값의 1과 "1"은 같은 값을 나타냄.
            "1" => "두 번째 값", // 같은 키값을 사용하여 두 번 선언했기 때문에 나중에 선언된 "두 번째 값"만 남게됨.
            10 => "세 번째 값",
            -10 => "네 번째 값"
        );
        var_dump($arr);
        echo "<br>";
        echo $arr[1];
        echo "<br>";
        echo $arr["1"];
        echo "<br>";
        echo $arr[10];
        echo "<br>";
        echo $arr[-10];
        ```
        첫 번째 배열 요소의 키값인 1과 두 번째 배열 요소의 키값인 "1"은 같은 값으로 저장된다.<br/>
        PHP에서는 같은 키값으로 여러 번 맵(map)을 선언할 경우, 그 키에 해당하는 값을 계속 덮어써서 맨 마지막에 선언된 값만을 저장하게 된다.<br/><br/>

6. 객체(object)
    + 객체(object)는 클래스의 인스턴스(instance)를 저장하기 위한 타입이다.
    + 객체는 프로퍼티(properties)과 메소드(methods)를 포함할 수 있다.
    ```php
    class PHP
    {
        public function PHP2()
        {
            $this->lec_01 = "PHP";
            $this->lec_02 = "WITH";
            $this->lec_03 = "MySQL";
        }
    }

    $str = new PHP;
    $str->PHP2();
    echo $str->lec_01;
    echo "<br>";
    echo $str->lec_02;
    echo "<br>";
    echo $str->lec_03;
    ```

7. 리소스(resource)
    + 리소스(resource)는 PHP 외부에 존재하는 외부 자원을 의미한다.
    + 리소스는 데이터베이스 함수 등에서 데이터베이스 연결 등을 반환할 때 사용된다.<br/><br/>

8. NULL
    + NULL은 오직 한 가지 값(NULL 상수)만을 가질 수 있는 특별한 타입이다.
    + NULL 타입의 변수란 아직 어떠한 값도 대입되지 않은 변수를 의미한다.
    ```php
    $a;
    var_dump($a);


    $a = 100;
    var_dump($a);


    unset($a);
    var_dump($a);
    ```
    PHP에서 초기화하지 않은 변수는 NULL로 자동 초기화한다.<br/>
    -> var_dump($a)에서 화면에 에러가 발생하여 Undefined variable $a 즉 지정되지 않았다는 에러가 출력된다.<br/>
    삭제되거나 존재하지 않는 변수를 참조할 경우에도 NULL을 반환한다.<br/>
    -> 위 코드에선 반환전 $a의 값을 삭제했으므로 마찬가지로 에러가 발생한다.<br/><br/>


## 타입 변환
 + 자동 타입 변환<br/>
    PHP에서는 변수의 타입은 해당 변수에 대입하는 값에 따라 자동으로 결정되기 때문에 변수를 선언할 때 타입을 명시할 필요가 없다.<br/>
    이러한 타입 변환을 자동 타입 변환이라 한다.<br/>
    ```php
    $auto = "문자열"; // string
    echo $auto."<br>";
    $auto = 10;       // int
    echo $auto."<br>";
    $auto = 3.14;     // float
    echo $auto."<br>";
    ```
    <br/>

 + 강제 타입 변환<br/>
    PHP에서는 변수에 값을 대입할 때마다 변수의 타입이 그것에 맞게 변하게 된다.<br/>
    하지만 사용자가 직접 데이터의 타입을 변환해야 할 경우도 많다.<br/>
    PHP에서는 이러한 강제 타입 변환을 타입 캐스트 연산자인 괄호(())를 사용하여 수행할 수 있다.<br/>
    변환시키고자 하는 데이터나 변수의 앞에 괄호를 붙이고, 그 괄호 안에 변환할 타입을 적으면 된다.<br/>
    ```php
    $cast1 = 10;
    var_dump($cast1);           // int(10)  
    echo "<br>";

    $cast2 = (boolean) $cast1;
    var_dump($cast2);           // bool(true)
    echo "<br>";

    $cast3 = 0;
    var_dump($cast3);           // int(0)  
    echo "<br>";

    $cast4 = (boolean) $cast3;
    var_dump($cast4);           // bool(false)
    ```
    <br/>

 + 가변 변수<br/>
    PHP에서는 변수의 타입뿐만 아니라 변수의 이름까지 동적으로 바꿀 수 있다.<br/>
    이러한 변수를 가변 변수(variable variables)라고 하며, 해당 변수의 값을 또 다른 변수의 이름으로 취급한다.
    ```php
    $PHP = "HTML";
    $HTML = "CSS";
    $CSS = "JavaScript";
    $JavaScript = "Ajax";
    $Ajax = "PHP";  

    echo $PHP;       // HTML
    echo "<br>";
    echo $$PHP;      // $HTML -> CSS
    echo "<br>";
    echo $$$PHP;     // $$HTML -> $CSS -> JavaScript
    echo "<br>";
    echo $$$$PHP;    // $$$HTML -> $$CSS -> $JavaScript -> Ajax
    echo "<br>";
    echo $$$$$PHP;   // $$$$HTML -> $$$CSS -> $$JavaScript -> $Ajax -> PHP
    echo "<br>";
    echo $$$$$$PHP;  // $$$$$HTML -> $$$$CSS -> $$$JavaScript -> $$Ajax -> $PHP -> HTML
    echo "<br>";
    echo $$$$$$$PHP; // $$$$$$HTML -> $$$$$CSS -> $$$$JavaScript -> $$$Ajax -> $$PHP -> $HTML -> CSS ...
    ```
    각 변수가 가지는 값이 변수의 이름인 변수의 값으로 변경된다.<br/>
    즉 $PHP = "HTML"이면 $$PHP는 $PHP의 값이 "HTML"이었으므로 HTML이라는 변수의 값인 "CSS"라는 값을 가지게 된다.<br/><br/>
------------
</div>
</details>
<br>

<details>
<summary>2021-04-25~26</summary>
<div markdown="2021-04-25~26">

## 2021-04-25~26
#### 중간고사

</div>
</details>
<br>

<details>
<summary>2021-04-27</summary>
<div markdown="2021-04-27">

## 2021-04-27
#### 개인사정으로 인한 지체

</div>
</details>
<br>

<details>
<summary>2021-04-28~?</summary>
<div markdown="2021-04-28~?">

## 2021-04-28~?
#### 졸업작품에 대한 회의와 화면공유로 실시간 소통 코딩, 개인 프로젝트로 인해 지체예정

</div>
</details>
<br>

<details>
<summary>2021-06-21</summary>
<div markdown="2021-06-21">

## 2021-06-21
#### 기말고사 이후 작성 시작
#### 표 내부 "|"의 글자가 제대로 작성되지 않는 문제로 "/"로 대체하였습니다.("||" -> "//")
------------
## 연산자
PHP는 다양한 연산을 위해 많은 종류의 연산자를 제공하고 있다.

### 산술 연산자(arithmetic operator)
산술 연산자는 사칙 연산을 다루는 가장 기본적이면서도 많이 사용하는 연산자이다.<br>
산술 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.<br>

|산술 연산자|설명|
|:--------:|:--------:|
|+|왼쪽의 피연산자에 오른쪽의 피연산자를 더함|
|-|왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌|
|*|왼쪽의 피연산자에 오른쪽의 피연산자를 곱함|
|/|왼쪽의 피연산자를 오른쪽의 피연산자로 나눔|
|%|왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함|
|**|왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 제곱함. (PHP 5.6에서 추가됨)|

```php
$num_01 = 10;
$num_02 = 4;

echo "+ 연산자에 의한 결과값은 ".($num_01 + $num_02)."입니다.<br>"; // 14
echo "- 연산자에 의한 결과값은 ".($num_01 - $num_02)."입니다.<br>"; // 6
echo "* 연산자에 의한 결과값은 ".($num_01 * $num_02)."입니다.<br>"; // 40
echo "/ 연산자에 의한 결과값은 ".($num_01 / $num_02)."입니다.<br>"; // 2.5
echo "% 연산자에 의한 결과값은 ".($num_01 % $num_02)."입니다.";     // 2
```

### 연산자의 우선순위(operator precedence)와 결합 방향(associativity)
연산자의 우선순위는 하나의 수식 내에 여러 연산자가 함께 등장할 때, 어느 연산자가 먼저 처리될 것인가를 결정한다.<br>
우선순위는 일반적인 수식과 같다. [] -> {} -> () -> *,/ -> +,-<br>

### PHP 연산자의 우선순위표
PHP에서 연산자의 우선순위와 결합 방향은 다음과 같다.<br>

|우선순위|연산자|설명|결합 방향|
|:--------:|:--------:|:--------:|:--------:|
|1|new|new 객체의 생성|-|
| |clone|객체의 복제|-|
|2|[]|배열|왼쪽에서 오른쪽으로|
|3|++|증가 연산자|-|
| |--|감소 연산자|-|
|4|(타입)|타입 캐스트 연산자|-|
| |~|비트 NOT 연산자|-|
| |-|음의 부호 (단항 연산자)|-|
|5|instanceof|객체|-|
|6|!|논리 NOT 연산자|오른쪽에서 왼쪽으로|
|7|*|곱셈 연산자|왼쪽에서 오른쪽으로|
| |/|나눗셈 연산자|왼쪽에서 오른쪽으로|
| |%|나머지 연산자|왼쪽에서 오른쪽으로|
|8|+|덧셈 연산자|왼쪽에서 오른쪽으로|
| |-|뺄셈 연산자|왼쪽에서 오른쪽으로|
|9|<<|비트 왼쪽 시프트 연산자|왼쪽에서 오른쪽으로|
| |>>|비트 오른쪽 시프트 연산자|왼쪽에서 오른쪽으로|
|10|<|관계 연산자(보다 작은)|-|
| |<=|관계 연산자(보다 작거나 같은)|-|
| |>|관계 연산자(보다 큰)|-|
| |>=|관계 연산자(보다 크거나 같은)|-|
| |<>|관계 연산자(와 같지 않은)|-|
|11|==|관계 연산자(와 같은)|-|
| |===|관계 연산자(와 같고 같은 타입)|-|
| |!=|관계 연산자(와 같지 않은)|-|
| |!==|관계 연산자(와 같지 않거나 다른 타입)|-|
|12|&|비트 AND 연산자|왼쪽에서 오른쪽으로|
|13|^|비트 XOR 연산자|왼쪽에서 오른쪽으로|
|14|"/"|비트 OR 연산자|왼쪽에서 오른쪽으로|
|15|&&|논리 AND 연산자|왼쪽에서 오른쪽으로|
|16|"//"|논리 OR 연산자|왼쪽에서 오른쪽으로|
|17|?:|삼항 연산자|오른쪽에서 왼쪽으로|
|18|=|대입 연산자|오른쪽에서 왼쪽으로|
| |+=|복합 대입 연산자(덧셈)|오른쪽에서 왼쪽으로|
| |-=|복합 대입 연산자(뺄셈)|오른쪽에서 왼쪽으로|
| |*=|복합 대입 연산자(곱셈)|오른쪽에서 왼쪽으로|
| |/=|복합 대입 연산자(나눗셈)|오른쪽에서 왼쪽으로|
| |%=|복합 대입 연산자(나머지)|오른쪽에서 왼쪽으로|
| |.=|복합 대입 연산자(문자열 추가)|오른쪽에서 왼쪽으로|
| |<<=|복합 대입 연산자(비트 왼쪽 시프트)|오른쪽에서 왼쪽으로|
| |>>=|복합 대입 연산자(비트 오른쪽 시프트)|오른쪽에서 왼쪽으로|
| |&=|복합 대입 연산자(비트 AND)|오른쪽에서 왼쪽으로|
| |'/='|복합 대입 연산자(비트 OR)|오른쪽에서 왼쪽으로|
| |^=|복합 대입 연산자(비트 XOR)|오른쪽에서 왼쪽으로|
|19|and|논리 AND 연산자|왼쪽에서 오른쪽으로|
|20|xor|논리 XOR 연산자|왼쪽에서 오른쪽으로|
|21|or|논리 OR 연산자|왼쪽에서 오른쪽으로|
|22|,|쉼표 연산자|왼쪽에서 오른쪽으로|

위의 표에서 나온 순서대로 우선순위가 빠른 연산자가 가장 먼저 실행된다.<br>
또한, 같은 우선순위를 가지는 연산자가 둘 이상 있을 때에는 결합 순서에 따라 실행 순서가 결정된다.<br>


### 대입 연산자(assignment operator)
대입 연산자는 변수에 값을 대입할 때 사용하는 이항 연산자이며, 피연산자들의 결합 방향은 오른쪽에서 왼쪽이다.<br>

|대입 연산자|설명|
|:--------:|:--------:|
|=|왼쪽의 피연산자에 오른쪽의 피연산자를 대입함|

### 복합 대입 연산자
PHP에서는 대입 연산자와 산술 연산자 등을 결합한 다양한 복합 대입 연산자를 제공한다.<br>
복합 대입 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 오른쪽에서 왼쪽이다.<br>

|복합 대입 연산자|설명|
|:--------:|:--------:|
|+=|왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 왼쪽의 피연산자에 대입함|
|-=|왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 왼쪽의 피연산자에 대입함|
|*=|왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 왼쪽의 피연산자에 대입함|
|/=|왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 왼쪽의 피연산자에 대입함|
|%=|왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입함|
|.=|왼쪽 피연산자의 문자열에 오른쪽 피연산자의 문자열을 추가한 후, 왼쪽의 피연산자에 대입함|
|<<=|왼쪽의 피연산자의 비트를 오른쪽의 피연산자만큼 전부 왼쪽으로 이동시킨 후, 그 결과를 왼쪽의 피연산자에 대입함|
|>>=|왼쪽의 피연산자의 비트를 부호를 유지하면서 오른쪽의 피연산자만큼 전부 오른쪽으로 이동시킨 후, 그 결과를 왼쪽의 피연산자에 대입함|
|&=|왼쪽의 피연산자와 오른쪽의 피연산자의 논리식이 모두 true면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함|
|"/="|왼쪽의 피연산자나 오른쪽의 피연산자의 논리식 중 하나라도 true면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함|
|^=|왼쪽 피연산자의 논리식과 오른쪽 피연산자의 논리식이 서로 다르면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함|

```php
$num_01 = 7;
$num_02 = 7;
$num_03 = 7;

echo "- 연산자에 의한 결과값은 ".($num_01 = $num_01 - 5)."입니다.<br>"; // 2
echo "-= 연산자에 의한 결과값은 ".($num_02 -= 5)."입니다.<br>";         // 2
echo "=- 연산자에 의한 결과값은 ".($num_03 =- 5)."입니다.";             // -5
```

### 증감 연산자(increment and decrement operator)
증감 연산자는 피연산자를 1씩 증가 혹은 감소시킬 때 사용하는 연산자이다.<br>
이 연산자는 피연산자가 단 하나뿐인 단항 연산자이다.<br>
증감 연산자는 해당 연산자가 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서 및 결과가 달라진다.<br>

|증감 연산자|설명|
|:--------:|:--------:|
|++$var|먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 수행함|
|$var++|먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴|
|--$var|먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 수행함|
|$var--|먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴|

```php
$num_01 = 7;
$num_02 = 7;

echo "++\$num_01 에 의한 결과값은 ".(++$num_01 - 5)."이고, 변수의 값은 {$num_01}로 변했습니다.<br>";
echo "\$num_02++ 에 의한 결과값은 ".($num_02++ - 5)."이고, 변수의 값은 {$num_02}로 변했습니다.";
```
위의 예제에서 첫 번째 연산은 변수 $num_01의 값을 먼저 1 증가시킨 후에 전체 연산을 수행한다.<br>
하지만 두 번째 연산은 먼저 모든 연산을 끝마친 후에 변수 $num_02의 값을 1 증가시킨다.<br>
따라서 두 번째 연산에서 변수 $num_02의 증가는 전체 연산에 어떠한 영향도 미치지 않는다.<br>


### 증감 연산자의 연산 순서
증감 연산자는 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서가 달라진다.

```php
$x = 10;
$y = $x-- + 5 + --$x;

echo "변수 \$x 의 값은 ".$x."이고, 변수 \$y 의 값은 ".$y."으로 변경되었습니다.";
```

위 예제 해석
1. ($x-- + 5)의 식이 실행되어 $y는 15의 값을 가진다.
2. $x-- 부분이 실행되어 $x는 9의 값을 가지게 된다.
3. --$x부분이 실행되어 $x는 8의 값을 가지게 된다.
4. $y 값(15)과 $x(8)의 값이 더해져 23의 값을 가지게 되고 echo부분이 실행되어 화면에 출력된다.<br>
// 출력 : 변수 $x 의 값은 8이고, 변수 $y 의 값은 23으로 변경되었습니다.<br>
// echo부분 $x앞 '\'이 표시는 문자 그대로를 출력하라는 의미로 php의 변수선언 '$'를 무력화한다고 보면 된다.<br>

### 비교 연산자(comparison operator)
비교 연산자는 피연산자 사이의 상대적인 크기를 판단하여, 참(true)과 거짓(false)을 반환한다.<br>
비교 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.<br>

|비교 연산자|설명|
|:--------:|:--------:|
|==|왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 참을 반환함|
|===|왼쪽의 피연산자와 오른쪽의 피연산자가 같고, 같은 타입이면 참을 반환함 (PHP 4에서 추가됨)|
|!=|왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 참을 반환함|
|<>|왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 참을 반환함|
|!==|왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않거나, 타입이 다르면 참을 반환함 (PHP 4에서 추가됨)|
|<|왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 참을 반환함|
|<=|왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 참을 반환함|
|>|왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 참을 반환함|
|>=|왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 참을 반환함|

```php
$num_01 = 3;
$num_02 = 3.0;
$num_03 = 3;

var_dump($num_01 == $num_02);  // true
var_dump($num_01 === $num_02); // false
var_dump($num_01 != $num_03);  // false
```

#### 다양한 타입의 비교
PHP에서는 다양한 타입의 값을 서로 비교해야 할 때 다음 규칙에 따라 비교한다.<br>

|피연산자1|피연산자2|비교 규칙|
|:--------:|:--------:|:--------:|
|bool, null|모두|둘 다 불리언으로 변환한 후 비교함 (false < true)|
|string, resource, integer, float|string, resource, integer, float|숫자로 시작하는 문자열과 리소스는 숫자로 변환한 후 비교함|
|object|object|내장 클래스는 자신의 비교 함수를 정의할 수 있으나, 다른 클래스끼리 비교할 수는 없음|
|array|array|배열끼리의 비교는 같은 키를 가지는 값을 서로 비교함. 이때 피연산자1 배열의 키가 피연산자2 배열에 존재하지 않으면 비교할 수 없으며, 배열 요소의 수가 적은 쪽이 작은 거로 판단됨|
|array|모두|배열이 항상 큰 거로 판단됨|
|object|모두|객체가 항상 큰 거로 판단됨|

```php
var_dump(0 < true);           // true
var_dump("123abc" == 123);    // false
var_dump("123abc" === 123);   // false

$arr_01 = array("a" => 10);
$arr_02 = array("a" => 5);
$arr_03 = array("a" => 5, "c" => 7);

var_dump($arr_01 >= $arr_02); // true
var_dump($arr_01 >= $arr_03); // false
var_dump("문자열" < $arr_01); // true
```

### 논리 연산자(logical operator)
논리 연산자는 논리식을 판단하여, 참(true)과 거짓(false)을 반환한다.<br>
and, or, xor 연산자는 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.<br>
! 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽이다.<br>

|논리 연산자|설명|
|:--------:|:--------:|
|and|논리식이 모두 참이면 참을 반환함 (AND 연산)|
|or|논리식 중에서 하나라도 참이면 참을 반환함 (OR 연산)|
|xor|논리식이 서로 다르면 참을 반환함 (XOR 연산)|
|&&|논리식이 모두 참이면 참을 반환함 (AND 연산)|
|"//"|논리식 중에서 하나라도 참이면 참을 반환함 (OR 연산)|
|!|논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함 (NOT 연산)|

다음은 논리 연산자의 모든 동작의 결과를 보여주는 진리표(truth table)이다.<br>
|A|B|A and B (A && B)|A or B (A // B)|A xor B|!A|
|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
|true|false|false|true|true|false|
|false|true|false|true|true|true|
|false|false|false|false|false|true|

```php
$num_01 = true;
$num_02 = false;

var_dump($num_01 and $num_02);      // true and false -> false
var_dump($num_01 or $num_02);       // true or false -> true
var_dump($num_01 xor $num_02);      // true xor false -> true
var_dump( (3 < 5) or ("12" > 20) ); // true or false -> true
```

### 비트 연산자(bitwise operator)
비트 연산자는 논리 연산자와 비슷하지만, 비트(bit) 단위로 논리 연산을 수행한다.<br>
또한, 비트 단위로 전체 비트를 왼쪽이나 오른쪽으로 이동시킬 때도 사용한다.<br>

|비트 연산자|설명|
|:--------:|:--------:|
|&|대응되는 비트가 모두 1이면 1을 반환함 (비트 AND 연산)|
|"/"|대응되는 비트 중에서 하나라도 1이면 1을 반환함 (비트 OR 연산)|
|^|대응되는 비트가 서로 다르면 1을 반환함 (비트 XOR 연산)|
|~|비트를 1이면 0으로, 0이면 1로 반전시킴 (비트 NOT 연산)|
|<<|지정한 수만큼 비트를 전부 왼쪽으로 이동시킴 (left shift 연산)|
|>>|부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴 (right shift 연산)|

다음 그림은 비트 AND 연산자(&)의 동작을 나타낸다.<br>
이처럼 비트 AND 연산자는 대응되는 두 비트가 모두 1일 때만 1을 반환하며, 다른 경우는 모두 0을 반환한다.<br>
![img1](http://www.tcpschool.com/lectures/img_php_bitwise_and.png)<br>

다음 그림은 비트 OR 연산자(|)의 동작을 나타낸다.<br>
이처럼 비트 OR 연산자는 대응되는 두 비트 중 하나라도 1이면 1을 반환하며, 두 비트가 모두 0일 때만 0을 반환한다.<br>
![img2](http://www.tcpschool.com/lectures/img_php_bitwise_or.png)<br>


다음 그림은 비트 XOR 연산자(^)의 동작을 나타낸다.<br>
이처럼 비트 XOR 연산자는 대응되는 두 비트가 서로 다르면 1을 반환하고, 서로 같으면 0을 반환한다.<br>
![img3](http://www.tcpschool.com/lectures/img_php_bitwise_xor.png)<br>

다음 그림은 비트 NOT 연산자(~)의 동작을 나타낸다.<br>
이처럼 비트 NOT 연산자는 해당 비트가 1이면 0을 반환하고, 0이면 1을 반환한다.<br>
![img4](http://www.tcpschool.com/lectures/img_php_bitwise_not.png)<br>

```php
$num_01 = 15;
$num_02 = 8;

echo "~ 연산자에 의한 결괏값은 ".(~$num_01)."입니다.<br>";    // 1의 보수 -> (-16)
echo "<< 연산자에 의한 결괏값은 ".($num_02<<1)."입니다.<br>"; // 곱하기 2 -> (16)
echo ">> 연산자에 의한 결괏값은 ".($num_02>>1)."입니다.";     // 나누기 2 -> (4)
```


위 예제는 왼쪽 시프트 연산자(<<)를 사용하여, 해당 데이터의 모든 비트를 왼쪽으로 1비트씩 이동시키고 있다.<br>
![img5](http://www.tcpschool.com/lectures/img_php_left_shift.png)<br>
그 결과 해당 데이터의 값은 처음 값에 2를 곱한 것과 같아진다.<br>

오른쪽 시프트 연산자(>>)를 사용하여, 해당 데이터의 모든 비트를 오른쪽으로 1비트씩 이동시키고 있다.<br>
![img6](http://www.tcpschool.com/lectures/img_php_right_shift.png)<br>
그 결과 해당 데이터의 값은 처음 값에 2를 나눈 것과 같아진다.<br>

### 삼항 연산자(ternary operator)
삼항 연산자는 유일하게 피연산자를 세 개나 가지는 조건 연산자이다.<br>
문법은 다음과 같다.<br>
 > 조건식 ? 반환값1 : 반환값2
물음표(?) 앞의 표현식에 따라 결괏값이 참이면 반환값 1을 반환하고, 결괏값이 거짓이면 반환값 2를 반환한다.<br>

```php
$num_01 = 15;
$num_02 = 8;
$result = ($num_01 > $num_02) ? $num_01 : $num_02;

echo "둘 중에 더 큰수는 {$result}입니다.";
```
삼항 연산자는 짧은 if / else 문 대신 사용할 수 있으며, 코드를 간결하게 만들어 준다.<br>

### 문자열 연산자(string operator)
PHP에서 문자열 연산자(.)를 사용하여 문자열을 연결할 수 있다.<br>
이 연산자는 얼핏 보기에는 연산자가 아닌 것처럼 보이지만 양쪽에 위치한 두 문자열을 연결해 주는 역할을 한다.<br>
또한, echo() 함수에서는 쉼표 연산자(,)를 이용하여 문자열을 연결할 수 있다.<br>

```php
$str_01 = "PHP 수업";
$str_02 = "에 오신것을 환영합니다!";

echo "두 문자열을 합친 문자열은 '".($str_01.$str_02)."'입니다.<br>";
echo $str_01, $str_02;
```
PHP에서는 문자열 내에 변수의 이름을 포함시켜 해당 변수의 값을 동적으로 문자열에 삽입할 수도 있다.<br>

### 배열 합집합 연산자(array union operator)
배열 합집합 연산자(+)는 피연산자로 오는 두 배열의 합집합을 반환한다.<br>
왼쪽 피연산자로 오는 배열의 키값은 유지하면서, 거기에 맞춰 오른쪽 피연산자로 오는 배열을 덧붙이는 방식을 취한다.<br>
따라서 같은 키에 대한 값에는 왼쪽 피연산자로 오는 배열의 값이 저장된다.<br>

```php
$arr_01 = array("1st" => "PHP", "2nd" => "MySQL");
$arr_02 = array("1st" => "HTML", "2nd" => "CSS", "3rd" => "JavaScript");

$result_01 = $arr_01 + $arr_02; // [PHP, MySQL, JavaScript]
var_dump($result_01);
$result_02 = $arr_02 + $arr_01; // [HTML, CSS, JavaScript]
var_dump($result_02);
```
위의 예제에서 두 배열의 첫 번째와 두 번째 요소의 키값이 서로 같다.<br>
이때 어느 집합이 앞에 위치하는가에 따라 합집합 연산의 결과가 달라지는 것을 확인할 수 있다.<br>

```php
$arr_01 = array("PHP", "MySQL");
$arr_02 = array("HTML", "CSS", "JavaScript");

$result_01 = $arr_01 + $arr_02; // [PHP, MySQL, JavaScript]
var_dump($result_01);
$result_02 = $arr_02 + $arr_01; // [HTML, CSS, JavaScript]
var_dump($result_02);
```
위의 예제에서 인덱스를 가지는 배열에서도 배열 합집합 연산은 같은 결과를 반환하는 것을 확인할 수 있다.<br>

### instanceof 연산자
instanceof 연산자는 다음과 같은 사항을 확인하고자 할 때 사용할 수 있다.<br>

1. 해당 변수가 어떤 클래스(class)에서 생성된 객체(object)인지를 확인할 때
2. 해당 변수가 부모 클래스(parent class)에서 상속받은 클래스인지를 확인할 때
3. 해당 변수가 클래스의 인스턴스(instance)인지 아닌지를 확인할 때
4. 해당 변수가 인터페이스(interface)로 구현한 클래스의 객체 인스턴스(object instance)인지 아닌지를 확인할 때

```php
interface Interface01
{}

class Class01
{}

class Class02 extends Class01 implements Interface01
{}

/* 어떤 클래스(class)에서 생성된 객체(object)인지를 확인할 때 */
$var_01 = new Class01; // Class01 클래스 객체를 생성함.
var_dump($var_01 instanceof Class01);     // true
var_dump($var_01 instanceof Class02);     // false

/* 부모 클래스(parent class)에서 상속받은 클래스인지를 확인할 때 */
$var_02 = new Class02; // Class02 클래스 객체를 생성함.
var_dump($var_02 instanceof Class01);     // true
var_dump($var_02 instanceof Class02);     // true

/* 클래스의 인스턴스(instance)인지 아닌지를 확인할 때 */
$var_03 = new Class01; // Class01 클래스 객체를 생성함.
var_dump(!($var_03 instanceof Class02));  // true

/* 인터페이스(interface)로 구현한 클래스의 객체 인스턴스(object instance)인지 아닌지를 확인할 때 */
$var_04 = new Class02; // Class02 클래스 객체를 생성함.
var_dump($var_04 instanceof Class02);     // true
var_dump($var_04 instanceof Interface01); // true
```
------------

</div>
</details>
<br>

<details>
<summary>2021-06-22</summary>
<div markdown="2021-06-22">

## 2021-06-22
------------
### 조건문

### PHP 표현식
표현식(expressions)은 PHP에서 가장 중요한 구성요소이다.
표현식이란 모든 것이 값을 갖는다는 의미이며, PHP에서 사용하는 거의 모든 것이 표현식에 속한다.
표현식에는 변수와 상수, 함수까지도 포함되며, 제어문이나 명령문도 모두 표현식에 속한다.

### 제어문
표현식 중에서도 프로그램의 순차적인 흐름을 제어해야 할 때 사용하는 명령문을 제어문이라고 한다.
이러한 제어문에는 조건문, 반복문 등이 포함된다.

### 조건문
조건문이란 프로그램 내에서 주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문이다.
조건문 중에서 가장 기본이 되는 명령문은 if 문이다.

### if 문
if 문은 조건식의 결과가 참(true)이면 주어진 명령문을 실행하며, 거짓(false)이면 아무것도 실행하지 않는다.

```php
$num_01 = 10;
$num_02 = 20;
if ($num_01 == $num_02) {
    echo "{$num_01}과 {$num_02}은 같은 수입니다.";
}
if ($num_01 < $num_02) {
    echo "{$num_01}은 {$num_02}보다 작은 수입니다.";
}
if ($num_01 > $num_02) // 실행될 명령문이 한 줄뿐이라면 중괄호({})를 생략할 수 있음.
    echo "{$num_01}은 {$num_02}보다 큰 수입니다.";
```

### else 문
if 문과 같이 사용할 수 있는 else 문은 if 문의 조건식 결과가 거짓(false)일 때 주어진 명령문을 실행한다.
```php
$num_01 = 20;
$num_02 = 20;
if ($num_01 == $num_02) {
    echo "{$num_01}과 {$num_02}은 같은 수입니다.";
}
else {
    if ($num_01 < $num_02)
        echo "{$num_01}은 {$num_02}보다 작은 수입니다.";
    else // $num_01 > $num_02
        echo "{$num_01}은 {$num_02}보다 큰 수입니다.";
}
```

### elseif 문(PHP에서는 elseif와 else if를 둘 다 사용할 수 있다.)
elseif 문은 if 문처럼 조건식을 설정할 수 있으므로, 중첩된 if 문을 좀 더 간결하게 표현할 수 있다.
하나의 조건문 안에서 if 문과 else 문은 단 한 번만 사용될 수 있다.
하지만 elseif 문은 여러 번 사용되어 다양한 조건을 설정할 수 있다.

```php
$num_01 = 30;
$num_02 = 20;
if ($num_01 == $num_02) {
    echo "{$num_01}과 {$num_02}은 같은 수입니다.";
}
elseif ($num_01 < $num_02) {
    echo "{$num_01}은 {$num_02}보다 작은 수입니다.";
}
else { // $num_01 > $num_02
    echo "{$num_01}은 {$num_02}보다 큰 수입니다.";
}
```

### 삼항 연산자에 의한 조건문
PHP에서는 C언어와 마찬가지로 간단한 if / else 문을 삼항 연산자를 이용하여 간단히 표현할 수 있다.
삼항 연산자에 대한 더 자세한 사항은 PHP 기타 연산자 수업에서 확인할 수 있다.

### switch 문
switch 문은 if / else 문과 마찬가지로 주어진 조건 값에 따라 프로그램이 다른 명령을 수행하도록 하는 조건문이다.
이러한 switch 문은 if / else 문보다 가독성 측면에서 더 좋다.
default 절은 조건 값이 위에 나열된 어떠한 case 절에도 해당하지 않을 때 실행된다.
이 구문은 반드시 존재해야 하는 것은 아니며, 필요할 때만 선언할 수 있다.
각 case 절 및 default 절은 반드시 break 키워드를 포함하고 있어야 한다.
break 키워드는 조건 값에 해당하는 case 절이나 default 절이 실행된 뒤에 전체 switch 문을 빠져나가게 해준다.

```php
$var = "오렌지";
switch ($var) {
    case "귤":
        echo "여기 있는 과일은 귤입니다.";
        break;
    case "사과":
        echo "여기 있는 과일은 사과입니다.";
        break;
    case "바나나":
        echo "여기 있는 과일은 바나나입니다.";
        break;
    default:
        echo "여기 있는 과일은 처음 보는 과일입니다.";
        break;
}
```

### 반복문
반복문이란 프로그램 내에서 같은 명령을 일정 횟수만큼 반복하여 수행하는 명령문이다.
프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 반복문은 가장 많이 사용되는 명령문 중 하나이다.
PHP에서 사용되는 대표적인 반복문의 형태는 다음과 같다.
1. while 문
2. do / while 문
3. for 문
4. foreach 문

### while 문
while 문은 특정 조건을 만족할 때까지 계속 주어진 명령문을 반복해서 실행하는 명령문이다.
while 문은 우선 표현식이 참(true)인지를 판단하여 참이면 내부의 명령문을 실행한다.
내부의 명령문을 전부 실행하고 나면, 다시 표현식으로 돌아와 또 한 번 표현식이 참인지를 판단하게 된다.
이렇게 표현식의 검사를 통해, 반복해서 실행되는 반복문을 루프(loop)라고 한다.

```php
$i = 0;
while ($i < 5) {
    echo ($i++)."<br>";
}
```

while 문 내부에 표현식의 결과를 변경하는 명령문이 존재하지 않을 경우 프로그램은 루프를 영원히 반복하게 된다.
이것을 무한 루프(infinite loop)에 빠졌다고 하며, 무한 루프에 빠진 프로그램은 영원히 종료되지 않는다.
무한 루프는 특별히 의도한 경우가 아니라면 반드시 피해야 하는 상황이다.
따라서 while 문을 작성할 때는 표현식의 결과가 어느 순간에는 거짓(false)을 갖도록 표현식를 변경하는 명령문을 반드시 포함해야 한다.

### do / while 문
while 문은 루프에 진입하기 전에 먼저 표현식부터 검사한다.
하지만 do / while 문은 먼저 루프를 한 번 실행한 후에 표현식을 검사한다.
즉, do / while 문은 표현식의 결과와 상관없이 무조건 한 번은 루프를 실행한다.

```php
$i = 0;
$j = 0;
while ($i > 5) {
    echo "변수 i의 값은 ".(++$i)."입니다.<br>";
}
do { // do / while문은 조건식과 상관없이 반드시 한 번은 루프를 실행함
    echo "변수 j의 값은 ".(++$j)."입니다.<br>";
} while ($j > 5);
```

### for 문
for 문은 while 문과는 달리 자체적으로 초기식, 표현식, 증감식을 모두 포함하고 있는 반복문이다.
따라서 while 문보다는 좀 더 간결하게 반복문을 표현할 수 있다.
for 문을 구성하는 초기식, 표현식, 증감식은 각각 생략될 수 있다.
또한, 쉼표 연산자(,)를 사용하면 여러 개의 초기식이나 증감식을 동시에 사용할 수도 있다.
for 문을 사용하면 앞선 예제의 while 문을 더욱 더 간결하게 표현할 수 있다.

```php
for ($i = 0; $i < 5; $i++) {
    echo "{$i}<br>";
}
```

### foreach 문
foreach 문은 일반적인 for 문과는 전혀 다른 형태의 반복문이다.
foreach 문은 배열의 모든 요소를 손쉽게 순회할 수 있도록 해준다.
이 반복문은 루프마다 배열의 각 요소를 지정된 변수에 대입한다.
이렇게 대입받은 변수를 이용하면 루프 안에서 배열의 각 요소에 순차적으로 접근할 수 있다.
따라서 foreach 문은 정확히 배열의 길이(length)만큼 반복된다.

```php
$arr = array(2, 4, 6, 8);
foreach ($arr as $value) {
    echo "변수 \$value의 현재값은 {$value}입니다.<br>";
}
unset($value);
```

다음 예제는 배열의 값뿐만 아니라 키값도 저장하여 활용하는 예제이다.

```php
$arr = array(
    "둘" => 2,
    "넷" => 4,
    "여섯" => 6,
    "여덟" => 8,
);
foreach ($arr as $key => $value) {
    echo "배열 \$arr에서 키값 '{$key}'에 대한 값은 {$value}입니다.<br>";
}
unset($value);
```

### 루프의 제어
일반적으로 조건식의 검사를 통해 루프로 진입하면, 다음 조건식을 검사하기 전까지 루프 안에 있는 모든 명령문을 실행한다.
사용자는 continue 문과 break 문을 통해, 이러한 일반적인 루프의 흐름을 직접 제어할 수 있다.

### continue 문
continue 문은 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 조건식의 판단으로 넘어가게 한다.
보통 반복문 내에서 특정 조건에 대한 처리를 제외하고자 할 때 자주 사용된다.

```php
$exceptNum = 4;
for ($i=0; $i<=100; $i++) {
    if ($i % $exceptNum == 0)
        continue;
    echo "{$i} ";
}
```

### break 문
break 문은 루프 내에서 사용한다.
해당 반복문을 완전히 종료시키고, 반복문 다음에 위치한 명령문으로 이동시킨다.
즉, 루프 내에서 조건식의 판단 결과에 상관없이, 반복문을 완전히 빠져나가고 싶을 때 사용한다.

```php
$sum = 0;
$startNum = 1;
$endNum = 100;
$i = $startNum;
while (true) { // 일부러 만든 무한 루프임.
    $sum += $i;
    if ($i == $endNum)
        break;
    $i++;
}
echo "{$startNum}에서부터 {$endNum}까지 더한 값은 {$sum}입니다.";
```

### goto 문
goto 문은 프로그램의 흐름을 지정된 레이블(label)로 무조건 변경하는 명령문이다.
goto 문은 다른 제어문과는 다르게 아무 조건 없이 제어를 옮겨준다.
따라서 가장 손쉽게 사용할 수 있지만, 반면에 프로그램의 흐름을 매우 복잡하게 만들기도 한다.
이러한 단점 때문에 현재는 거의 사용하지 않는다.

### 제어문의 대체 문법
PHP는 제어문을 위해 사용할 수 있는 또 하나의 대체 문법을 제공하고 있다.
이 대체 문법은 조건문에서는 if 문과 switch 문, 반복문에서는 while 문, for 문과 foreach 문에 사용할 수 있다.
대체 문법의 사용 방법은 우선 제어문의 여는 괄호({)를 콜론(:)으로 대체한다.
그리고 닫는 괄호(})를 각각 endif;, endswitch;, endwhile;, endfor;, endforeach;로 대체하면 된다.

```php
$var = 5;
if ($var > 6):
echo "변수의 값은 6보다 큽니다.";
elseif ($var == 6):
echo "변수의 값은 6입니다.";
elseif ($var < 6):
echo "변수의 값은 6보다 작습니다.";
endif;
```
------------

</div>
</details>
<br>